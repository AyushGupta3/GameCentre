package fall2018.csc2017.treasurehunt;

import org.junit.Test;

import java.util.HashSet;
import java.util.Set;
import java.util.Stack;

import static org.junit.Assert.assertTrue;

/**
 * A set of tests for TreasureHuntBoardGenerator.
 */
public class TreasureHuntBoardGeneratorTest {


    /**
     * Return a Path that begins at the bottom left corner and ends at the upper right corner. Each
     * element in the stack returned is a String that is either "up", "down", "left", or "right",
     * and these four strings represent the direction that the player should move to get to the
     * treasure.
     *
     * @param board   that board generated by TreasureHuntBoardGenerator.
     * @param visited the tiles that are already visited.
     * @param row     the current row that this algorithm is in.
     * @param col     the current column that this algorithm is in.
     * @return a Path that begins at the person's position and ends at the treasure's position.
     */
    private Stack<String> generatePath(TreasureHuntBoard board, Set<TreasureHuntTile>
            visited, int row, int col) {
        if (row == 0 && col == board.getBoardSize() - 1) {
            return new Stack<>();
        }
        TreasureHuntTile tile = board.getTile(row, col);
        visited.add(tile);
        if (tile.getType() == TreasureHuntTile.BRICK)
            return null;
        if (row > 0 && !visited.contains(board.getTile(row - 1, col))) {
            Stack<String> path = generatePath(board, visited, row - 1, col);
            if (path != null) {
                path.add("up");
                return path;
            }
        }
        if (row < board.getBoardSize() - 1 && !visited.contains(board.getTile(row + 1, col))) {
            Stack<String> path = generatePath(board, visited, row + 1, col);
            if (path != null) {
                path.add("down");
                return path;
            }
        }
        if (col > 0 && !visited.contains(board.getTile(row, col - 1))) {
            Stack<String> path = generatePath(board, visited, row, col - 1);
            if (path != null) {
                path.add("left");
                return path;
            }
        }
        if (col < board.getBoardSize() - 1 && !visited.contains(board.getTile(row, col + 1))) {
            Stack<String> path = generatePath(board, visited, row, col + 1);
            if (path != null) {
                path.add("right");
                return path;
            }
        }
        return null;
    }

    /**
     * Test the method generateSolvableBoard.
     */
    @Test
    public void testGenerateSolvableBoard() {

        for (int i = 0; i != 100; i++) {
            TreasureHuntBoard board = TreasureHuntBoardGenerator.generateSolvableBoard(8);
            assertTrue(checkValidBoard(board));
        }
        for (int i = 0; i != 100; i++) {
            TreasureHuntBoard board = TreasureHuntBoardGenerator.generateSolvableBoard(9);
            assertTrue(checkValidBoard(board));
        }
        for (int i = 0; i != 100; i++) {
            TreasureHuntBoard board = TreasureHuntBoardGenerator.generateSolvableBoard(10);
            assertTrue(checkValidBoard(board));
        }
    }

    /**
     * Return true if this board can be solved and that the person and treasure are in the right
     * position.
     *
     * @param board the board generated by TreasureHuntBoardGenerator.
     * @return true if this board can be solved and that the person and the treasure are in the
     * rightt position.
     */
    private boolean checkValidBoard(TreasureHuntBoard board) {
        int curRow = board.getBoardSize() - 1;
        int curCol = 0;
        Stack<String> path = generatePath(board, new HashSet<TreasureHuntTile>(), curRow, curCol);
        if (path == null)
            return false;
        while (!path.isEmpty()) {
            if (curRow == board.getBoardSize() - 1 && curCol == 0) {
                if (board.getTile(curRow, curCol).getType() != TreasureHuntTile.PERSON)
                    return false;
            } else if (board.getTile(curRow, curCol).getType() != TreasureHuntTile.BLANK) {
                return false;
            }
            String nextMove = path.pop();
            switch (nextMove) {
                case "up":
                    curRow -= 1;
                    break;
                case "down":
                    curRow += 1;
                    break;
                case "left":
                    curCol -= 1;
                    break;
                case "right":
                    curCol += 1;
                    break;
            }
        }
        boolean correctPersonPosition = board.getTile(board.getBoardSize() - 1,
                0).getType() == TreasureHuntTile.PERSON;
        boolean correctTreasurePosition = board.getTile(0,
                board.getBoardSize() - 1).getType() == TreasureHuntTile.TREASURE;
        return board.getTile(curRow, curCol).getType() == TreasureHuntTile.TREASURE &&
                correctPersonPosition && correctTreasurePosition;
    }
}
